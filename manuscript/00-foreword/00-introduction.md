# Introdução

O gerenciamento de estado em aplicações *web* tornou-se um tópico popular nos anos recentes. [Single page applications (SPAs)][1] - que são providas de uma só vez por um servidor web, permanecendo interativas no lado do cliente - têm que fazer o gerenciamento de estados *client-side*. Elam precisam manter o estado consistente na aplicação de *frontend*, sem que sejam feitas outras requisições à aplicação de *backend*. O usuário deve ter uma experiência suave e prazeirosa, quando as utilizada. Isto desde a abertura de um *popup* na sua aplicação, devendo ser possível abri-lo e fechá-lo. Alguém precisa, então, estar ciente deste estado. Mas, quem será que o gerencia, já que ele não está na aplicação de *backend*?

[jQuery][2] foi uma popular biblioteca, antes das primeiras soluções SPA - como Angular, Ember e Backbone - aparecerem. De início, o gerenciamento de estado, por si só, não era um problema tão grande em jQuery, porque a biblioteca era geralmente utilizada apenas para manipulações do DOM. Você poderia adicionar animações ao seu HTML, programar sua lógica de estilização ou adicionar e remover *DOM nodes*. Aplicações *web* tornaram-se mais prazeirosas através de uma maior interatividade.

Eventualmente, o código jQuery (e JavaScript, no geral) aumentou em proporção, ao contrário de HTML e CSS. As pessoas escreviam aplicações *frontend* mais sofisticadas. Na maior parte do tempo, isto se transformava em um código *jQuery* bagunçado, onde não somente o gerenciamento de estado era um problema, mas também as boas práticas de código limpo eram ausentes. Não havia solução de arquitetura geral para este tipo de aplicações e as pessoas sofriam para as de maior escala ainda manuteníveis.

Um tempo depois, surgiram soluções de *single page application* (SPA), como Angular, Ember e Backbone, dando um *framework* arquitetural apropriado à essas aplicações de *frontend* desestruturadas. A maior parte das soluções de SPA eram baseadas no [padrão model-view-controller (MVC)][3] para arquitetar a aplicação. Os *frameworks* mencionados continham tudo que você pudesse precisar para construir sua aplicação sofisticada, desde uma camada de visão para exibir HTML no navegador, até uma camada de modelo para interagir com o seu *backend*. O termo SPA lhes foi atribuído, pois aplicações assim são providas de uma só vez pelo servidor *web*, como uma única página, sendo depois operadas inteiramente no lado do cliente. Elas são bolhas de HTML ligado a JavaScript, contendo tudo que as aplicações precisam para trabalhar *client-side*. Quando se navega para uma página diferente, sob outra URL, não ocorre nenhuma chamada adicional ao servidor para obter novos HTML e JavaScript. SPAs só interagem com o *backend* para receber ou mandar dados. Portanto, a única coisa que é modificada é o estado interno da aplicação, porque dados são escritos e lidos no/do *backend* e também porque interações como *popups*, filtros e modais precisam funcionar. Mas, quem gerencia este estado, para manter a consistência no lado do cliente da aplicação?

Apesar de esses *frameworks* SPA terem estabelecido melhores práticas, padrões e arquiteturas para a primeira geração de SPAs, gerenciamento de estado ainda era uma questão recorrente para eles. Quando havia interação com o *backend* para obter dados, não era claro como gerenciá-los de maneira previsível. Quando elementos relacionados à *views*, como modais e *popups*, eram acionados no *frontend*, geralmente não havia uma melhor prática para gerenciar seus estados. Cada *framework* tentava aplicar sua própria solução. Eventualmente, as pessoas acabaram inventando as suas próprias práticas e bibliotecas, mas gerenciar o estado com regras claras nunca se tornou uma experiência consistente e previsível.

Havia um grande defeito com estas soluções SPA, motivo primário deste problema: Como *frameworks*, elas tentavam resolver muitas questões de uma só vez.  Mas, por serem os primeiros de sua espécie, não tiveram a chance de solucionar todos os problemas do mundo das SPAs. Eventualmente, o fizeram em outra iteração, quando outras soluções entraram em cena.

A segunda geração de soluções SPA, entre elas bibliotecas como React e Vue, mantiveram o foco em partes menores da aplicação. Focaram na camada de visão. Ficaria para o engenheiro decidir sobre bibliotecas adicionais para outros problemas específicos. [Isto foi, em primeiro lugar, o que fez de React uma biblioteca poderosa][4], porque todos poderiam extender suas aplicações escolhendo outras bibliotecas que resolvem problemas menores específicos.

Nos dias de hoje, uma tonelada de artigos e bibliotecas tentam resolver a questão de gerenciamento de estado. É difícil achar uma única fonte consistente da verdade para aprender sobre o assunto em aplicações modernas. Apesar disto, soluções como React possuem sua própria implementação de gerenciamento de estado para o estado local em componentes. Existem também outras bibliotecas externas, como Redux e MobX, que estabelecem um gerenciamento de estado mais sofisticado.

Existe a carência de um guia, que navegue por todas estas soluções, apontando claramente as diferenças e benefícios no gerenciamento de estado. Frequentemente, os guias se esquecem de ensinar sobre o problema primeiro. Além disso, ao invés de demonstrar com uma abordagem mínima, utilizam uma com engenharia muito complexa. Poderia ser bem mais simples. Só é preciso um recurso como guia de gerenciamento de estado em aplicações modernas, de forma consistente e construtiva. Esta é a missão deste livro.

Se desejar aprender alguma coisa, deverá fazê-lo passo a passo. Tente resolver um problema de forma atômica, depois outro. Não aplique tudo de uma vez, entenda o problema e resolva-o. Esta é minha intenção com este livro: Ele não somente ensina Redux com React, mas também o gerenciamento de estado em aplicações modernas. Ele vai além da documentação das bibliotecas dedicadas ao assunto, utilizando o aprendizado em aplicações do mundo real no livro.

O livro segue com o tema central de gerenciamento de estado em aplicações. Ele começa com o gerenciamento do estado local em uma biblioteca focada na camada de visão (React), aponta os problemas com ele em aplicações maiores e irá se encaminhar para uma soluções mais sofisticadas, como Redux e MobX. Enquanto lê o livro, você irá se deparar com trechos de código que ilustram problemas e soluções. Lhe encorajo a brincar com estes trechos, para ganhar experiência prática. Você pode até tentar aplicá-los em seu editor de texto pessoal, não hesite em fazê-lo desde cedo. Mas, não se preocupe se não funcionar de início. Você será conduzido por mim a aplicar seus novos conhecimentos em um editor ao longo de vários capítulos.

Esses são os heróis deste livro: Estado Local (em React), Redux e MobX. Não teria sido possível escrever o livro sem as pessoas inovadoras, por trás destas soluções: [Dan Abramov][5], [Andrew Clark][6] e [Michel Weststrate][7]. Acho que posso agradecê-los em nome da comunidade, por seus esforços em tornar o gerenciamento de estados em aplicações modernas uma experiência consistente e prazeirosa.

[1]:	https://en.wikipedia.org/wiki/Single-page_application
[2]:	https://en.wikipedia.org/wiki/JQuery
[3]:	https://en.wikipedia.org/wiki/Model-view-controller
[4]:	https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/
[5]:	https://twitter.com/dan_abramov
[6]:	https://twitter.com/acdlite
[7]:	https://twitter.com/mweststrate