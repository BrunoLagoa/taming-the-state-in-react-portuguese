# Introdução

O gerenciamento de estado em aplicações *web* tornou-se um tópico popular nos anos recentes. [Single page applications (SPAs)][1] - que são providas de uma só vez por um servidor web, permanecendo interativas no lado do cliente - têm que fazer o gerenciamento de estados *client-side*. Elam precisam manter o estado consistente na aplicação de *frontend*, sem que sejam feitas outras requisições à aplicação de *backend*. O usuário deve ter uma experiência suave e prazeirosa, quando as utilizada. Isto desde a abertura de um *popup* na sua aplicação, devendo ser possível abri-lo e fechá-lo. Alguém precisa, então, estar ciente deste estado. Mas, quem será que o gerencia, já que ele não está na aplicação de *backend*?

[jQuery][2] foi uma popular biblioteca, antes das primeiras soluções SPA - como Angular, Ember e Backbone - aparecerem. De início, o gerenciamento de estado, por si só, não era um problema tão grande em jQuery, porque a biblioteca era geralmente utilizada apenas para manipulações do DOM. Você poderia adicionar animações ao seu HTML, programar sua lógica de estilização ou adicionar e remover *DOM nodes*. Aplicações *web* tornaram-se mais prazeirosas através de uma maior interatividade.

Eventualmente, o código jQuery (e JavaScript, no geral) aumentou em proporção, ao contrário de HTML e CSS. As pessoas escreviam aplicações *frontend* mais sofisticadas. Na maior parte do tempo, isto se transformava em um código *jQuery* bagunçado, onde não somente o gerenciamento de estado era um problema, mas também as boas práticas de código limpo eram ausentes. Não havia solução de arquitetura geral para este tipo de aplicações e as pessoas sofriam para as de maior escala ainda manuteníveis.

Um tempo depois, surgiram soluções de *single page application* (SPA), como Angular, Ember e Backbone, dando um *framework* arquitetural apropriado à essas aplicações de *frontend* desestruturadas. A maior parte das soluções de SPA eram baseadas no [padrão model-view-controller (MVC)][3] para arquitetar a aplicação. Os *frameworks* mencionados continham tudo que você pudesse precisar para construir sua aplicação sofisticada, desde uma camada de visão para exibir HTML no navegador, até uma camada de modelo para interagir com o seu *backend*. O termo SPA lhes foi atribuído, pois aplicações assim são providas de uma só vez pelo servidor *web*, como uma única página, sendo depois operadas inteiramente no lado do cliente. Elas são bolhas de HTML ligado a JavaScript, contendo tudo que as aplicações precisam para trabalhar *client-side*. Quando se navega para uma página diferente, sob outra URL, não ocorre nenhuma chamada adicional ao servidor para obter novos HTML e JavaScript. SPAs só interagem com o *backend* para receber ou mandar dados. Portanto, a única coisa que é modificada é o estado interno da aplicação, porque dados são escritos e lidos no/do *backend* e também porque interações como *popups*, filtros e modais precisam funcionar. Mas, quem gerencia este estado, para manter a consistência no lado do cliente da aplicação?

Apesar de esses *frameworks* SPA terem estabelecido melhores práticas, padrões e arquiteturas para a primeira geração de SPAs, gerenciamento de estado ainda era uma questão recorrente para eles. Quando havia interação com o *backend* para obter dados, não era claro como gerenciá-los de maneira previsível. Quando elementos relacionados à *views*, como modais e *popups*, eram acionados no *frontend*, geralmente não havia uma melhor prática para gerenciar seus estados. Cada *framework* tentava aplicar sua própria solução. Eventualmente, as pessoas acabaram inventando as suas próprias práticas e bibliotecas, mas gerenciar o estado com regras claras nunca se tornou uma experiência consistente e previsível.

There was one major flaw with these SPA solutions that led to this problem in the first place: As frameworks, they tried to solve too many issues at once. Because they were the first of their species, they hadn't the chance to solve all issues in the world of SPAs. Eventually, they solved these issues in another iteration when other SPA solutions appeared at the scene.

The second generation of SPA solutions, among them libraries like React and Vue, focused only on smaller parts of the application. They focused on the view layer. It was up to the engineer to decide on additional libraries as solutions for specific problems. [That's what made React such a powerful library in the first place][4], because everyone could decide to extend their application with libraries that solve specific yet small problems.

Nowadays, a ton of articles and libraries try to solve the issue of state management. It is difficult to find a consistent source of truth to learn state management in modern applications. Even though, solutions like React have their own state management implementation for local state in components, there are more external solutions coming as libraries such as Redux and MobX that establish sophisticated state management.

Still, it lacks one guide to navigate through all these different solutions to make the differences and benefits of state management clear. Quite often, the guides miss the point of teaching the problem first. In addition, instead of showing the minimal approach, they try to fix the problem of state management by using over-engineered approaches. But it can be so much simpler. It only needs one resource to guide through state management in modern applications in a consistent and constructive way. And that's the mission of this book.

If you want to learn something, you have to do it step by step. Trying to solve each atomic problem after the next one. Don't apply everything at once. Understand the problem and solve it. That's my attempt with this book: It doesn't only teach Redux in React, but state management in modern applications. It goes beyond the documentation of state management libraries, but applies the learnings in real world applications in the book.

The book follows the central theme of state management in modern applications. It starts with local state management in a view library (React), points out the problems of it in larger applications and will lead over to sophisticated state management solutions such as Redux and MobX. While you read the book, you will find code playgrounds that illustrate problems and solutions. I encourage you to play around with these code playgrounds to have a practical experience. You can even try to apply these code snippets in your personal editor and play around with them. But don't worry if it doesn't work out in the beginning. You will be guided by me to apply your learnings in your editor in various chapters. However, don't hesitate to verify your learnings early on.

These are the heroes of the book: Local State (in React), Redux and MobX. It wouldn't have been possible to write the book without the innovators behind these solutions: [Dan Abramov][5], [Andrew Clark][6] and [Michel Weststrate][7]. I guess, I can thank them in the name of the community for their efforts to make state management in modern applications a consistent and enjoyable experience.

[1]:	https://en.wikipedia.org/wiki/Single-page_application
[2]:	https://en.wikipedia.org/wiki/JQuery
[3]:	https://en.wikipedia.org/wiki/Model-view-controller
[4]:	https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/
[5]:	https://twitter.com/dan_abramov
[6]:	https://twitter.com/acdlite
[7]:	https://twitter.com/mweststrate